// Benchmark boilerplate generated by Benchmark

import Benchmark
import Foundation
import SwiftOwnership

let benchmarks = {
    Benchmark.defaultConfiguration.scalingFactor = .one
    Benchmark.defaultConfiguration.metrics = [
        .cpuTotal,
        .peakMemoryResident,
        .mallocCountTotal,
        .allocatedResidentMemory,
        .objectAllocCount,
        .retainCount,
        .releaseCount
    ]
    Benchmark.defaultConfiguration.timeUnits = .milliseconds

    Benchmark("no array reuse") { benchmark in
        for _ in benchmark.scaledIterations {
            let file = try File(fileURL: URL(fileURLWithPath: "/Users/josipcavar/Downloads/archive/full.csv"))
            blackHole(try file.findLongestNoArray(reuse: true))
        }
    }

    Benchmark("non copyable reuse") { benchmark in
        for _ in benchmark.scaledIterations {
            let file = try File(fileURL: URL(fileURLWithPath: "/Users/josipcavar/Downloads/archive/full.csv"))
            blackHole(try file.findLongestNonCopyable())
        }
    }

    Benchmark("naive") { benchmark in
        for _ in benchmark.scaledIterations {
            let file = try File(fileURL: URL(fileURLWithPath: "/Users/josipcavar/Downloads/archive/full.csv"))
            blackHole(try file.findLongestNaive())
        }
    }

    Benchmark("cchar no reuse") { benchmark in
        for _ in benchmark.scaledIterations {
            let file = try File(fileURL: URL(fileURLWithPath: "/Users/josipcavar/Downloads/archive/full.csv"))
            blackHole(try file.findLongestCCharArray(reuse: true))
        }
    }

    Benchmark("cchar reuse") { benchmark in
        for _ in benchmark.scaledIterations {
            let file = try File(fileURL: URL(fileURLWithPath: "/Users/josipcavar/Downloads/archive/full.csv"))
            blackHole(try file.findLongestCCharArray(reuse: true))
        }
    }
}
